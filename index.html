<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Gingerbolt Fresh</title>
<style>
  :root{ --vh:1vh; --bg:#0f1320; --ink:#ffffff; --accent:#ff6fa3; --indigo:#5865F2; }
  *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
  html,body{
    margin:0; padding:0; height:100%; overflow:hidden; background:#000; color:var(--ink);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", sans-serif;
    -webkit-user-select:none; user-select:none;
  }
  canvas{
    display:block; width:100vw; height:calc(var(--vh) * 100);
    background:#000; margin:0 auto;
    position:relative; z-index:0;
  }

  /* Start UI */
  .stack{ position:fixed; left:50%; transform:translateX(-50%); width:min(92vw,560px); z-index:10; pointer-events:auto; }
  .stack[hidden]{ display:none; }
  #front{ top:18vh; display:flex; flex-direction:column; gap:14px; align-items:center; text-align:center; }
  .title{ font-weight:900; font-size:clamp(36px,10vw,84px); letter-spacing:1px; text-shadow:0 0 30px rgba(255,255,255,.55); }
  .sub{ opacity:.95; max-width:42ch; line-height:1.4 }
  .btn{
    background:linear-gradient(180deg,#ffd3e3,#ff6fa3);
    color:#2b0f1b; border:0; padding:14px 24px; border-radius:18px; font-weight:800;
    box-shadow:0 10px 28px rgba(0,0,0,.35); cursor:pointer; font-size:18px; min-width:220px;
  }
  .btn:active{ transform:translateY(1px) scale(.98); }

  /* Mobile controls */
  .controls{ position:fixed; inset:0; pointer-events:none; z-index:6; }
  .controls[hidden]{ display:none; }
  .laneBtn{
    position:absolute; width:86px; height:86px; border-radius:20px; border:0;
    background:rgba(20,24,30,.5); color:#fff; font-size:28px;
    box-shadow:0 10px 26px rgba(0,0,0,.4); pointer-events:auto; transform:translate(-50%,-50%);
    backdrop-filter: blur(6px);
  }
  .laneBtn:active{ transform:translate(-50%,-50%) scale(.96); }
  @media (min-width:900px){ .controls{ display:none !important; } }
</style>
</head>
<body>
  <canvas id="c"></canvas>

  <!-- Start screen -->
  <div id="front" class="stack">
    <div class="title">GINGERBOLT</div>
    <div class="sub">Arcade lane runner. Weave past trees and mud, snack for energy, and tap ⚡ to dash. Set a new global best.</div>
    <button id="start" class="btn" type="button">Start Game</button>
  </div>

  <!-- Touch arrows -->
  <div id="controls" class="controls" hidden>
    <button id="left"  class="laneBtn" aria-label="Left">◀</button>
    <button id="right" class="laneBtn" aria-label="Right">▶</button>
  </div>

<script>
/* ========================= real vh for iOS ========================= */
function setVH(){ const vv=visualViewport; const h=vv?vv.height:innerHeight; document.documentElement.style.setProperty('--vh', (h/100)+'px'); }
setVH(); if(window.visualViewport){ visualViewport.addEventListener('resize', setVH, {passive:true}); visualViewport.addEventListener('scroll', setVH, {passive:true}); }
addEventListener('orientationchange', ()=>setTimeout(setVH, 250), {passive:true});

/* ========================= canvas setup ========================= */
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d', { alpha:false, desynchronized:true });
function vp(){ const vv=visualViewport; return vv?{w:Math.floor(vv.width), h:Math.floor(vv.height)}:{w:innerWidth|0, h:innerHeight|0}; }
let {w:W, h:H} = vp();
let DPR = 1;
function resize(){
  const v = vp(); W=v.w; H=v.h; DPR=Math.max(1, Math.min(3, devicePixelRatio||1));
  cvs.style.width = W+'px'; cvs.style.height = H+'px';
  cvs.width = Math.floor(W*DPR); cvs.height = Math.floor(H*DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  calcCamera();
  layoutControls();
}
addEventListener('resize', resize, {passive:true});

/* ========================= camera and projection =========================
   World uses depth z in [0..1], where z=1 is at the player (near),
   z=0 is at the horizon (far). We linearly lerp lane centers and widths.
*/
const CAM = {
  horizonY: 0, groundY: 0,
  farHalf: 0,   nearHalf: 0,
  farCenters: [0,0,0],
  nearCenters: [0,0,0],
};
function calcCamera(){
  CAM.horizonY = Math.round(H * 0.26);
  CAM.groundY  = Math.round(H * 0.92);
  CAM.farHalf  = Math.max(70,  Math.min(W*0.20, 150)); // road half width at horizon
  CAM.nearHalf = Math.max(180, Math.min(W*0.46, 320)); // road half width near player

  const lanes = 3;
  const laneFarW  = (CAM.farHalf  * 2) / lanes;
  const laneNearW = (CAM.nearHalf * 2) / lanes;

  for(let i=0;i<lanes;i++){
    const xFar1  = (W/2 - CAM.farHalf)  + i*laneFarW + laneFarW/2;
    const xNear1 = (W/2 - CAM.nearHalf) + i*laneNearW + laneNearW/2;
    CAM.farCenters[i]  = xFar1;
    CAM.nearCenters[i] = xNear1;
  }
}
// project lane index and depth z→screen x,y and a size scale
function project(lane, z){
  const u = z;                 // u near
  const v = 1 - z;             // v far
  const x = CAM.nearCenters[lane]*u + CAM.farCenters[lane]*v;
  const y = CAM.groundY*u + CAM.horizonY*v;
  // perspective scale: small at far, big near, smooth curve
  const s = 0.35*v + 1.00*u;   // about 0.35 at far, 1.0 near
  return { x, y, s };
}

/* ========================= scene art ========================= */
function sky(){
  // sky gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, '#6db6ff');
  g.addColorStop(0.5,'#89d0ff');
  g.addColorStop(0.65,'#b9e7ff');
  g.addColorStop(1, '#6fbf54');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // mountains
  const baseY = CAM.horizonY + 18;
  ctx.fillStyle = '#4d6aa3';
  ctx.beginPath();
  ctx.moveTo(0, baseY+20);
  const peaks = 6, span = W/(peaks-1);
  for(let i=0;i<peaks;i++){
    const px = i*span;
    const py = baseY - 30 - Math.sin(i*1.3)*26 - (i%2?30:0);
    ctx.lineTo(px, py);
  }
  ctx.lineTo(W, baseY+20);
  ctx.closePath(); ctx.fill();

  // parallax clouds
  const t = performance.now()*0.00006;
  drawCloud(W*(0.1+(t%1)), CAM.horizonY-80, 120);
  drawCloud(W*(0.55+((t*1.2)%1)), CAM.horizonY-58, 160);
  drawCloud(W*(0.85+((t*0.7)%1))-W, CAM.horizonY-100, 110);
}
function drawCloud(x,y,r){
  ctx.save(); ctx.globalAlpha = .85;
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.arc(x,y,r*.36,0,Math.PI*2);
  ctx.arc(x+r*.24,y+6,r*.28,0,Math.PI*2);
  ctx.arc(x-r*.20,y+8,r*.26,0,Math.PI*2);
  ctx.arc(x+r*.02,y-10,r*.22,0,Math.PI*2);
  ctx.fill(); ctx.restore();
}

function drawGroundAndRoad(){
  // grass
  const gg = ctx.createLinearGradient(0,CAM.horizonY,0,H);
  gg.addColorStop(0,'#67ba52'); gg.addColorStop(1,'#3e8f3e');
  ctx.fillStyle = gg; ctx.fillRect(0,CAM.horizonY,W,H-CAM.horizonY);

  // road body trapezoid
  const leftFar  = W/2 - CAM.farHalf,  rightFar  = W/2 + CAM.farHalf;
  const leftNear = W/2 - CAM.nearHalf, rightNear = W/2 + CAM.nearHalf;

  const road = ctx.createLinearGradient(0,CAM.horizonY,0,CAM.groundY);
  road.addColorStop(0,'#8c6b50');
  road.addColorStop(1,'#6f523f');
  ctx.fillStyle = road;
  ctx.beginPath();
  ctx.moveTo(leftFar, CAM.horizonY);
  ctx.lineTo(rightFar, CAM.horizonY);
  ctx.lineTo(rightNear, CAM.groundY);
  ctx.lineTo(leftNear, CAM.groundY);
  ctx.closePath(); ctx.fill();

  // lane lines that truly converge
  ctx.strokeStyle='rgba(0,0,0,.22)'; ctx.lineWidth=2;
  const lanes = 3, laneFarW=(CAM.farHalf*2)/lanes, laneNearW=(CAM.nearHalf*2)/lanes;
  for(let i=1;i<lanes;i++){
    const x1 = (W/2 - CAM.farHalf)  + i*laneFarW;
    const x2 = (W/2 - CAM.nearHalf) + i*laneNearW;
    ctx.beginPath(); ctx.moveTo(x1, CAM.horizonY); ctx.lineTo(x2, CAM.groundY); ctx.stroke();
  }

  // soft road vignette
  const vg = ctx.createRadialGradient(W/2, H*.62, Math.min(W,H)*.22, W/2, H*.62, Math.max(W,H)*.88);
  vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,0,.36)');
  ctx.fillStyle = vg; ctx.fillRect(0,0,W,H);
}

/* ========================= entities ========================= */
function withShadow(color, blur, oy, fn){
  ctx.save(); ctx.shadowColor=color; ctx.shadowBlur=blur; ctx.shadowOffsetX=0; ctx.shadowOffsetY=oy; fn(); ctx.restore();
}
function drawTree(x,y,s){
  const w=42*s, h=76*s;
  withShadow('rgba(0,0,0,.35)', 10, 5, ()=>{
    // trunk
    ctx.fillStyle = '#6d3f17';
    const tw = w*.28, th = h*.52, tx = x - tw/2, ty = y + h*.12, r = tw*.35;
    ctx.beginPath();
    ctx.moveTo(tx+r,ty);
    ctx.lineTo(tx+tw-r,ty);
    ctx.quadraticCurveTo(tx+tw,ty,tx+tw,ty+r);
    ctx.lineTo(tx+tw,ty+th-r);
    ctx.quadraticCurveTo(tx+tw,ty+th,tx+tw-r,ty+th);
    ctx.lineTo(tx+r,ty+th);
    ctx.quadraticCurveTo(tx,ty+th,tx,ty+th-r);
    ctx.lineTo(tx,ty+r);
    ctx.quadraticCurveTo(tx,ty,tx+r,ty);
    ctx.closePath(); ctx.fill();

    // crown
    ctx.fillStyle = '#2f8c34';
    ctx.beginPath(); ctx.arc(x, y-h*.06, h*.34, 0, Math.PI*2); ctx.fill();
  });
}
function drawMud(x,y,s){
  const w=60*s, h=26*s;
  withShadow('rgba(0,0,0,.30)', 8, 4, ()=>{
    const g = ctx.createRadialGradient(x,y,1, x,y, Math.max(w,h));
    g.addColorStop(0,'#6a4a3a'); g.addColorStop(1,'#3e2723');
    ctx.fillStyle = g; ctx.beginPath(); ctx.ellipse(x,y,w*.5,h*.5,0,0,Math.PI*2); ctx.fill();
  });
}
function drawPickupMouse(x,y,s){
  const t=performance.now()*0.006, wob=Math.sin(t+x*.01)*1.2*s;
  withShadow('rgba(0,0,0,.25)', 6, 2, ()=>{
    ctx.fillStyle='#c7a17a';
    ctx.beginPath(); ctx.ellipse(x,y+wob,12*s,7*s,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(x+9*s,y-1*s+wob,6*s,5*s,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#d8d9dd'; ctx.beginPath(); ctx.arc(x+12*s,y-5*s+wob,2.8*s,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+7.5*s,y-6*s+wob,2.2*s,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#b78963'; ctx.lineWidth=1.4*s;
    ctx.beginPath(); ctx.moveTo(x-12*s,y+2*s+wob); ctx.quadraticCurveTo(x-18*s,y+6*s+wob,x-22*s,y+3*s+wob); ctx.stroke();
    ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(x+11*s,y-2*s+wob,1.4*s,0,Math.PI*2); ctx.fill();
  });
}
function drawPickupBird(x,y,s){
  const flap = Math.sin(performance.now()*0.02 + x*0.03)*6*s;
  withShadow('rgba(0,0,0,.25)',6,2,()=>{
    ctx.fillStyle='#8ec0ff'; ctx.beginPath(); ctx.ellipse(x,y,12*s,7*s,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#b9d9ff';
    ctx.save(); ctx.translate(x-6*s,y-4*s); ctx.rotate(flap*0.02);
    ctx.beginPath(); ctx.ellipse(0,0,8*s,4*s,0,0,Math.PI*2); ctx.fill(); ctx.restore();
    ctx.fillStyle='#ffb74d'; ctx.beginPath(); ctx.moveTo(x+10*s,y); ctx.lineTo(x+16*s,y-2*s); ctx.lineTo(x+10*s,y-4*s); ctx.closePath(); ctx.fill();
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x+2*s,y-2*s,1.4*s,0,Math.PI*2); ctx.fill();
  });
}
function drawPickupBolt(x,y,s){
  const base = 24*s;
  ctx.save(); ctx.translate(x,y);
  const glow = ctx.createRadialGradient(0,0,0,0,0,base*1.6);
  glow.addColorStop(0,'rgba(255,235,120,.9)'); glow.addColorStop(1,'rgba(255,235,120,0)');
  ctx.globalCompositeOperation='lighter';
  ctx.fillStyle=glow; ctx.beginPath(); ctx.arc(0,0,base*1.6,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation='source-over';
  const g = ctx.createLinearGradient(0,-base,0,base);
  g.addColorStop(0,'#fff9bf'); g.addColorStop(.5,'#ffd864'); g.addColorStop(1,'#ffb300');
  ctx.fillStyle=g; ctx.beginPath();
  ctx.moveTo(0,-base*.9); ctx.lineTo(8,-base*.1); ctx.lineTo(2,-base*.1);
  ctx.lineTo(14, base*.7); ctx.lineTo(-4, base*.05); ctx.lineTo(2, base*.05);
  ctx.closePath(); ctx.fill();
  ctx.restore();
}

/* player cat, clean shape */
function drawCat(x,y,s){
  const w=50*s, h=40*s; const t=performance.now()*0.006;
  const bob = Math.sin(t*3)*1.0*s;
  withShadow('rgba(0,0,0,.4)', 12, 5, ()=>{
    // body
    ctx.fillStyle='#d9862f'; ctx.beginPath(); ctx.ellipse(x, y+bob, w*.55, h*.48, 0, 0, Math.PI*2); ctx.fill();
    // stripe
    ctx.fillStyle='rgba(0,0,0,.15)'; ctx.beginPath(); ctx.ellipse(x, y-2*s+bob, w*.44, h*.16, 0, 0, Math.PI*2); ctx.fill();

    // head
    const hx = x + w*.34, hy = y - h*.46 + bob, r = h*.40;
    ctx.fillStyle='#d9862f'; ctx.beginPath(); ctx.arc(hx,hy,r,0,Math.PI*2); ctx.fill();
    // ears
    ctx.beginPath(); ctx.moveTo(hx-r*.25,hy-r*.85); ctx.lineTo(hx-r*.02,hy-r*.38); ctx.lineTo(hx-r*.62,hy-r*.32); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(hx+r*.12,hy-r*.90); ctx.lineTo(hx+r*.36,hy-r*.36); ctx.lineTo(hx-r*.02,hy-r*.40); ctx.closePath(); ctx.fill();
    // eyes
    ctx.fillStyle='#1a1a1a';
    ctx.beginPath(); ctx.ellipse(hx-r*.22, hy-r*.02, r*.12, r*.10, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(hx+r*.18, hy-r*.00, r*.12, r*.10, 0, 0, Math.PI*2); ctx.fill();
    // mouth
    ctx.strokeStyle='#7b3f1a'; ctx.lineWidth=1.6*s;
    ctx.beginPath(); ctx.moveTo(hx, hy+r*.10); ctx.lineTo(hx, hy+r*.20); ctx.stroke();
    // whiskers
    ctx.strokeStyle='rgba(255,255,255,.9)'; ctx.lineWidth=1.4*s;
    ctx.beginPath(); ctx.moveTo(hx+r*.02, hy+r*.12); ctx.lineTo(hx+r*.50, hy+r*.02); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(hx-r*.02, hy+r*.12); ctx.lineTo(hx-r*.50, hy+r*.02); ctx.stroke();
    // paws
    ctx.fillStyle='#c7772e';
    ctx.beginPath(); ctx.ellipse(x-w*.18, y+h*.50, w*.22, h*.10, 0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(x+w*.12,  y+h*.50, w*.22, h*.10, 0,0,Math.PI*2); ctx.fill();
    // tail
    ctx.strokeStyle='#b56a2a'; ctx.lineCap='round'; ctx.lineWidth=6*s;
    ctx.beginPath(); ctx.moveTo(x-w*.62, y+h*.12+bob);
    ctx.quadraticCurveTo(x-w*.72, y-h*.22, x-w*.18, y-h*.08);
    ctx.quadraticCurveTo(x-w*.02, y+h*.22, x+w*.02, y+h*.18);
    ctx.stroke();
  });
}

/* ========================= game state ========================= */
let mode = 'front';
let currentLane = 1;
let enemies=[], pickups=[], particles=[];
let score=0, fuel=100, meters=0;
let speed = 0.42;           // base forward speed
let speedGain = 0.00008;
let spawnTimer = 0;

let dash=false, dashTime=0;
const DASH_DUR=7.5, DASH_SPEED=1.28, DASH_SCORE=2;

function reset(){
  enemies.length=0; pickups.length=0; particles.length=0;
  score=0; fuel=100; meters=0;
  speed=0.42; spawnTimer=0; currentLane=1;
  dash=false; dashTime=0;
}

/* spawn helpers */
const SPAWN_GAP = 0.58;
function spawnEnemy(){
  const lane = (Math.random()*3)|0;
  const type = Math.random()<0.55 ? 'tree' : 'mud';
  enemies.push({ lane, z: 0, type, life:1 });
}
function spawnPickup(){
  const lane = (Math.random()*3)|0;
  const r=Math.random(); let type;
  if(r<.12) type='bolt';
  else if(r<.55) type='mouse';
  else type='bird';
  pickups.push({ lane, z: 0, type, life:1 });
}

/* ========================= update ========================= */
function update(dt){
  if(mode!=='game') return;

  const mul = dash?DASH_SPEED:1;
  const dps = speed*mul;
  speed += speedGain;

  spawnTimer += dt;
  if(spawnTimer > (dash?SPAWN_GAP*0.82:SPAWN_GAP)){
    spawnTimer = 0;
    if(Math.random()<0.65) spawnEnemy(); else spawnPickup();
  }

  enemies.forEach(e=> e.z = Math.min(1.15, e.z + dps*dt));
  pickups.forEach(p=> p.z = Math.min(1.15, p.z + dps*dt));
  enemies = enemies.filter(e=> e.z < 1.16);
  pickups = pickups.filter(p=> p.z < 1.16);

  // collisions when near the player
  const hitZ = 0.96;
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    if(e.z >= hitZ && e.lane===currentLane){
      enemies.splice(i,1);
      if(e.type==='mud'){ fuel=Math.max(0,fuel-10); score=Math.max(0,score-(dash?1:2)); }
      else { end(); return; }
    }
  }
  for(let i=pickups.length-1;i>=0;i--){
    const p=pickups[i];
    if(p.z >= hitZ && p.lane===currentLane){
      pickups.splice(i,1);
      if(p.type==='bolt'){ dash=true; dashTime=DASH_DUR; score+=8*DASH_SCORE; fuel=Math.min(100,fuel+6); }
      else if(p.type==='mouse'){ score+=(dash?6:3); fuel=Math.min(100,fuel+10); }
      else if(p.type==='bird'){ score+=(dash?6:3); fuel=Math.min(100,fuel+10); }
    }
  }

  if(dash){
    dashTime-=dt; if(dashTime<=0){ dash=false; dashTime=0; }
  }

  meters += (dps*dt)*180;
  fuel -= dt*(dash?2.4:2.0);
  if(fuel<=0) { end(); return; }
}

/* ========================= draw ========================= */
function draw(){
  // background first
  sky();
  drawGroundAndRoad();

  if(mode==='front'){
    // a subtle preview cat at player position
    const P = project(currentLane, 1.0);
    drawCat(P.x, CAM.groundY-18, 1.0);
    return;
  }

  // gather drawables and depth sort by z far to near
  const drawables=[];
  for(const e of enemies) drawables.push({z:e.z, lane:e.lane, kind:'e', t:e.type});
  for(const p of pickups) drawables.push({z:p.z, lane:p.lane, kind:'p', t:p.type});
  drawables.sort((a,b)=> a.z - b.z);

  for(const d of drawables){
    const P = project(d.lane, d.z);
    if(d.kind==='e'){
      if(d.t==='tree') drawTree(P.x, P.y, P.s);
      else drawMud(P.x, P.y, P.s);
    }else{
      if(d.t==='mouse') drawPickupMouse(P.x, P.y, P.s);
      else if(d.t==='bird') drawPickupBird(P.x, P.y, P.s);
      else drawPickupBolt(P.x, P.y, P.s);
    }
  }

  // player
  const PP = project(currentLane, 1.0);
  drawCat(PP.x, CAM.groundY-18, 1.0);

  // HUD
  ctx.fillStyle='#fff'; ctx.textAlign='left'; ctx.font='16px system-ui, sans-serif';
  ctx.fillText('Score: '+Math.round(score), 12, 22);
  ctx.fillText('Energy: '+Math.round(fuel), 12, 42);
  ctx.fillText('Meters: '+Math.round(meters), 12, 62);

  if(dash){
    const t='DASH '+dashTime.toFixed(1)+'s';
    const tw=ctx.measureText(t).width;
    ctx.fillStyle='#ffeb3b'; ctx.fillText(t, (W-tw)/2, 22);
  }
}

/* ========================= flow ========================= */
function start(){ reset(); mode='game'; ui(); }
function end(){ mode='front'; ui(); }
function ui(){
  document.getElementById('front').hidden = (mode==='game');
  document.getElementById('controls').hidden = !(mode==='game') || matchMedia('(min-width:900px)').matches;
  layoutControls();
}
document.getElementById('start').addEventListener('click', start);

/* ========================= input ========================= */
let keyLock=false;
addEventListener('keydown', e=>{
  if(mode!=='game') return;
  if(e.key==='ArrowLeft'){ if(!keyLock && currentLane>0) currentLane--; keyLock=true; }
  else if(e.key==='ArrowRight'){ if(!keyLock && currentLane<2) currentLane++; keyLock=true; }
});
addEventListener('keyup', e=>{ if(e.key==='ArrowLeft'||e.key==='ArrowRight') keyLock=false; });

const btnL = document.getElementById('left');
const btnR = document.getElementById('right');
function layoutControls(){
  const y = Math.min(H-10, H - Math.min(120, H*.12));
  const lx=[W/4, W/2, (3*W)/4];
  btnL.style.left = lx[0]+'px'; btnL.style.top = y+'px';
  btnR.style.left = lx[2]+'px'; btnR.style.top = y+'px';
}
btnL.addEventListener('pointerdown', ()=>{ if(mode==='game' && currentLane>0) currentLane--; });
btnR.addEventListener('pointerdown', ()=>{ if(mode==='game' && currentLane<2) currentLane++; });

/* ========================= game loop ========================= */
let last;
function loop(ts){
  if(last==null) last=ts;
  let dt=(ts-last)/1000; if(!Number.isFinite(dt)||dt<0) dt=0; dt=Math.min(dt,.05); last=ts;
  try{ update(dt); draw(); }catch(err){ console.error(err); }
  requestAnimationFrame(loop);
}

/* boot */
resize();
ui();
requestAnimationFrame(loop);
</script>
</body>
</html>
